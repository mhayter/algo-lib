/**
 * Simulated Annealing
 *
 * A probabilistic technique for approximating the global optimum of a given
 * function. A thorough explanation of this particular implementation can be
 * found at
 * http://apps.topcoder.com/forums/?module=Thread&threadID=696596&start=0.
 *
 * Parameters:
 *   - `Sol` (type): a class representing a solution. Must implement a
 *                   `ScoreType getScore()` method;
 *   - `Mut` (type): a class representing a mutation. Must implement:
 *       * `void init(Sol& sol)`, initializing a valid mutation for `sol`;
 *       * `ScoreType getScore()`, returning the score increase from the current
 *         solution to the mutated one (score of the mutation - original score);
 *       * `void apply(Sol& sol)`, applying the mutation to `sol`.
 *   - `solution`: the initial solution for the process to consider. Can be a
 *     random valid solution or a solution generated by a fast heuristic;
 *   - `maxt`: the initial (maximal) temperature. It should be large enough to
 *     make all mutations acceptable with good probability. A good idea may be
 *     to make the value proportional to the average mutation delta;
 *   - `mint`: the terminal (minimal) temperature. Should be less than the
 *     minimal possible mutation delta or less than the precision wanted;
 *   - `finishAtTime`: the time limit for the whole program to run, including
 *     initialization code.
 *
 * Returns:
 *   - `solution` is set to the solution with minimum score found.
 *
 * Complexity:
 *   Each iteration is bounded by the time it takes to initialize, calculate the
 *   score and apply a mutation to a solution.
 */

#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <sys/time.h>

using namespace std;

double getTime() {
  timeval tv; gettimeofday(&tv, NULL);
  return double (tv.tv_sec) + 0.000001 * tv.tv_usec;
}

double globalStartTime = getTime();

template<class Sol, class Mut> void simulatedAnnealing(
    Sol& solution, double maxt, double mint, double finishAtTime) {

  // sync means calculating current temperature from current work time
  static const int ITERS_PER_SYNC = 16;       // must be power of two
  // sometimes we dump current progress to stderr
  static const int ITERS_PER_DUMP = 0x40000;  // must be power of two
  // type of solution score
  typedef double ScoreType;

  // number of iterations done so far
  int iters = 0;
  // part of the full cooling schedule passed
  double done = 0.0;
  // best solution so far
  Sol best = solution;
  // number of accepted mutations overall
  int accMuts = 0;

  // time when the SA begins
  double startTime = getTime();
  // time dedicated for SA processing
  double hasTime = finishAtTime - (startTime - globalStartTime);

  while(true) {
    // dump stats so that you can watch the progress of SA
    if (!(iters & (ITERS_PER_DUMP - 1)))
      fprintf(stderr, "Iteration:%6d  Acc:%6d  Temp:%7.3lf  Score:%0.5lf\n",
              iters, accMuts, maxt * pow(mint / maxt, done),
              solution.getScore());
    // synchronize the temperature with time
    if (!(iters & (ITERS_PER_SYNC - 1))) {
      done = (getTime() - startTime) / hasTime;
      if (done >= 1.0) break;
    }

    // create mutation for current solution
    Mut mut;
    mut.init(solution);
    // get the score delta of the mutation
    ScoreType delta = mut.getScore();

    //if mutated solution is better, accept it
    bool move = false;
    if (delta <= 0) move = true;
    else {
      // otherwise calculate current temperature
      double temp = maxt * pow(mint / maxt, done);
      // and accept with the tricky probability
      move = ((double) rand() / (RAND_MAX)) < exp(-delta / temp);
    }

    // if mutation is accepted, apply it to the solution
    if (move) { accMuts++; mut.apply(solution); }

    // do not forget to store the best solution
    if (solution.getScore() < best.getScore()) best = solution;
    iters++;
  }

  //return the best solution as the result
  fprintf(stderr, "Simulated annealing made %d iterations (accepted: %d)\n",
          iters, accMuts);
  solution = best;
}

// -----------------------------------------------

#include <algorithm>
#include <ctime>

#define N 15
#define TIMELIMIT 9.8

int dist[][N] = {
    {0, 29, 82, 46, 68, 52, 72, 42, 51, 55, 29, 74, 23, 72, 46},
    {29, 0, 55, 46, 42, 43, 43, 23, 23, 31, 41, 51, 11, 52, 21},
    {82, 55, 0, 68, 46, 55, 23, 43, 41, 29, 79, 21, 64, 31, 51},
    {46, 46, 68, 0, 82, 15, 72, 31, 62, 42, 21, 51, 51, 43, 64},
    {68, 42, 46, 82, 0, 74, 23, 52, 21, 46, 82, 58, 46, 65, 23},
    {52, 43, 55, 15, 74, 0, 61, 23, 55, 31, 33, 37, 51, 29, 59},
    {72, 43, 23, 72, 23, 61, 0, 42, 23, 31, 77, 37, 51, 46, 33},
    {42, 23, 43, 31, 52, 23, 42, 0, 33, 15, 37, 33, 33, 31, 37},
    {51, 23, 41, 62, 21, 55, 23, 33, 0, 29, 62, 46, 29, 51, 11},
    {55, 31, 29, 42, 46, 31, 31, 15, 29, 0, 51, 21, 41, 23, 37},
    {29, 41, 79, 21, 82, 33, 77, 37, 62, 51, 0, 65, 42, 59, 61},
    {74, 51, 21, 51, 58, 37, 37, 33, 46, 21, 65, 0, 61, 11, 55},
    {23, 11, 64, 51, 46, 51, 51, 33, 29, 41, 42, 61, 0, 62, 23},
    {72, 52, 31, 43, 65, 29, 46, 31, 51, 23, 59, 11, 62, 0, 59},
    {46, 21, 51, 64, 23, 59, 33, 37, 11, 37, 61, 55, 23, 59, 0}
};

struct Sol {
  int order[N], total;

  void updateScore() {
    total = 0;
    for(int i = 0; i < N; i++)
      total += dist[order[i]][order[(i + 1) % N]];
  }

  double getScore() { return total; }
};

struct Mut {
  int i, total;
  Mut() { i = rand() % N; }

  void init(Sol& sol) {
    total = dist[sol.order[(i + 1) % N]][sol.order[i]] -
        dist[sol.order[i]][sol.order[(i + 1) % N]];

    total += dist[sol.order[(i - 1 + N) % N]][sol.order[(i + 1) % N]] -
        dist[sol.order[(i - 1 + N) % N]][sol.order[i]];

    total += dist[sol.order[i]][sol.order[(i + 2) % N]] -
        dist[sol.order[(i + 1) % N]][sol.order[(i + 2) % N]];
  }

  double getScore() { return total; }

  void apply(Sol& sol) {
    int tmp = sol.order[i];
    sol.order[i] = sol.order[(i + 1) % N];
    sol.order[(i + 1) % N] = tmp;

    sol.total += total;
  }
};

int main() {
  srand(time(NULL));

  Sol sol;
  for(int i = 0; i < N; i++) sol.order[i] = i;
  random_shuffle(sol.order, sol.order + N);
  sol.updateScore();

  double avgDist = 0.0;
  for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++)
      if (i != j) avgDist += dist[i][j];
  }
  avgDist /= N * (N - 1);

  double maxt = avgDist * 10.0;
  double mint = avgDist * 0.001;
  simulatedAnnealing<Sol, Mut>(sol, maxt, mint, TIMELIMIT);

  printf("%d\n", sol.total);
  return 0;
}
